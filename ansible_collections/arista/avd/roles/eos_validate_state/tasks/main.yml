---

    - name: include device intended structure configuration variables
      include_vars: '{{ inventory_dir }}/intended/structured_configs//{{ inventory_hostname }}.yml'
      delegate_to: localhost
      tags:
        - always

    - name: run show version on EOS devices
      eos_command:
        commands: "show version | json"
      register: eos_version
      tags:
        - platform_information

    - name: Display device platform and release information
      debug:
        msg: "The device {{ inventory_hostname }} is a {{ eos_version.stdout_lines.0.modelName }} model running EOS version {{ eos_version.stdout_lines.0.version }}"
      tags:
        - platform_information

    - name: collect power supplies status
      eos_command:
        commands: "show system environment power | json"
      register: power
      tags:
        - hardware

    - name: validate power supplies status
      assert:
        that:
          - item.value.state == 'ok'
        quiet: true
      loop: "{{ power.stdout_lines.0.powerSupplies | dict2items }}"
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - hardware

    - name: collect fan status
      eos_command:
        commands: "show system environment cooling | json"
      register: fan
      tags:
        - hardware

    - name: validate fan status (power supplies)
      assert:
        that:
          - item.status == 'ok'
        quiet: true
      loop: "{{ fan.stdout_lines.0.powerSupplySlots }}"
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - hardware

    - name: validate fan status (fan tray)
      assert:
        that:
          - item.status == 'ok'
        quiet: true
      loop: "{{ fan.stdout_lines.0.fanTraySlots }}"
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - hardware

    - name: validate temperature
      eos_command:
        commands: "show system environment temperature | json"
        wait_for: result[0].systemStatus eq 'temperatureOk'
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - hardware

    - name: collect transceivers inventory
      eos_command:
        commands: "show inventory | json"
      register: inventory
      tags:
        - hardware

    - name: validate transceivers manufacturers
      assert:
        that:
          - "item.value.mfgName in ['Not Present', 'Arastra, Inc.', 'Arista Networks']"
        quiet: true
      loop: "{{ inventory.stdout_lines.0.xcvrSlots | dict2items }}"
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - hardware

    - name: validate reload cause
      eos_command:
        commands: "show reload cause | json"
        wait_for: result[0].resetCauses[0].description eq 'Reload requested by the user.'
        retries: 2
        interval: 2
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - optional

    - name: validate NTP status
      eos_command:
        commands: "show ntp status"
        waitfor:
          - "result[0] contains 'synchronised to NTP server'"
        retries: 2
        interval: 2
      when: |
        (ntp_server.nodes is defined and ntp_server.nodes is not none)
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - avd

    - name: validate interfaces admin state
      eos_command:
        commands: "show interfaces {{ item.key }} description | json"
        waitfor:
          - result[0].interfaceDescriptions.{{ item.key }}.interfaceStatus eq 'up'
        retries: 2
        interval: 2
      loop: "{{ ethernet_interfaces | default({}) | dict2items }}"
      when: |
        (ethernet_interfaces is defined and ethernet_interfaces is not none)
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - avd

    - name: validate interfaces operational state
      eos_command:
        commands: "show interfaces {{ item.key }} description | json"
        waitfor:
          - result[0].interfaceDescriptions.{{ item.key }}.lineProtocolStatus eq 'up'
        retries: 2
        interval: 2
      loop: "{{ ethernet_interfaces | default({}) | dict2items }}"
      when: |
        (ethernet_interfaces is defined and ethernet_interfaces is not none)
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - avd

    - name: Gather LLDP topology
      eos_command:
        commands: "show lldp neighbors detail | json"
      ignore_errors: "{{ validation_mode_loose }}"
      register: lldp_topology_state
      tags:
        - lldp_topology

    - name: validate lldp topology
      assert:
        that:
          - lldp_topology_state.stdout[0].lldpNeighbors[ethernet_interface.key].lldpNeighborInfo[0] is defined
          - lldp_topology_state.stdout[0].lldpNeighbors[ethernet_interface.key].lldpNeighborInfo[0].systemName == ethernet_interface.value.peer + "." + hostvars[ethernet_interface.value.peer]['dns_domain']
          - lldp_topology_state.stdout[0].lldpNeighbors[ethernet_interface.key].lldpNeighborInfo[0].neighborInterfaceInfo.interfaceId == "\"" + ethernet_interface.value.peer_interface + "\""
        quiet: true
      loop: "{{ ethernet_interfaces | default({}) | dict2items }}"
      loop_control:
        loop_var: ethernet_interface
      when: |
        (ethernet_interfaces is defined and ethernet_interfaces is not none) and
        (ethernet_interface.value.peer is defined and ethernet_interface.value.peer is not none) and
        (ethernet_interface.value.peer_interface is defined and ethernet_interface.value.peer_interface is not none) and
        (hostvars[ethernet_interface.value.peer] is defined and hostvars[ethernet_interface.value.peer] is not none) and
        (hostvars[ethernet_interface.value.peer]['dns_domain'] is defined and hostvars[ethernet_interface.value.peer]['dns_domain'] is not none)
      ignore_errors: "{{ validation_mode_loose }}"
      register: lldp_topology_results
      tags:
        - lldp_topology

    - name: validate MLAG status
      eos_command:
        commands: "show mlag detail | json"
        waitfor:
          - "result[0].state eq 'active'"
          - "result[0].negStatus eq 'connected'"
        retries: 2
        interval: 2
      ignore_errors: "{{ validation_mode_loose }}"
      when: |
        (mlag_configuration is defined and mlag_configuration is not none)
      tags:
        - avd

    - name: Gather IP reachability state (directly connected interfaces)
      eos_command:
        commands: "ping {{ hostvars[ethernet_interface.value.peer]['ethernet_interfaces'][ethernet_interface.value.peer_interface]['ip_address'] | ipaddr('address')}} source {{ ethernet_interface.value.ip_address  | ipaddr('address')}} repeat 1"
      loop: "{{ethernet_interfaces | default({}) | dict2items}}"
      loop_control:
        loop_var: ethernet_interface
      ignore_errors: "{{ validation_mode_loose }}"
      when: |
        (ethernet_interfaces is defined and ethernet_interfaces is not none) and
        (ethernet_interface.value.type is defined and ethernet_interface.value.type is not none and ethernet_interface.value.type == 'routed') and
        (ethernet_interface.value.ip_address is defined and ethernet_interface.value.ip_address is not none) and
        (ethernet_interface.value.peer is defined and ethernet_interface.value.peer is not none) and
        (ethernet_interface.value.peer_interface is defined and ethernet_interface.value.peer_interface is not none) and
        (hostvars[ethernet_interface.value.peer]['ethernet_interfaces'][ethernet_interface.value.peer_interface]['ip_address'] is defined and
        hostvars[ethernet_interface.value.peer]['ethernet_interfaces'][ethernet_interface.value.peer_interface]['ip_address'] is not none)
      register: ip_reachability_state
      tags:
        - ip_reachability

    - name: validate ip reachability (directly connected interfaces)
      assert:
        that:
          - ip_reachability_test.stdout[0] | regex_search("1 received")
        quiet: true
      loop: "{{ ip_reachability_state.results }}"
      loop_control:
        loop_var: ip_reachability_test
      ignore_errors: "{{ validation_mode_loose }}"
      when: ( ip_reachability_test.skipped is not defined )
      register: ip_reachability_results
      tags:
        - ip_reachability

    - name: Gathter ip route summary and ArBGP state
      eos_command:
        commands: "show ip route summary"
      register: ip_route_summary
      tags:
        - ArBGP_state

    - name: validate ArBGP is configured and operating
      assert:
        that:
          - ip_route_summary.stdout_lines[0][0] | regex_search("multi-agent")
          - ip_route_summary.stdout_lines[0][1] | regex_search("multi-agent")
        quiet: yes
      when: ( service_routing_protocols_model is defined and service_routing_protocols_model == "multi-agent" )
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - ArBGP_state

    - name: gather bgp summary (ip and evpn)
      eos_command:
        commands:
          - command: "show ip bgp summary | json"
          - command: "show bgp evpn summary | json"
      when: |
        (router_bgp is defined and router_bgp is not none) and
        (router_bgp.neighbors is defined and router_bgp.neighbors is not none)
      register: bgp_summary
      tags:
        - bgp_session_state


    - name: Validate ip bgp neighbors peer state
      assert:
        that:
          - bgp_summary.stdout[0].vrfs.default.peers[bgp_neighbor.key].peerState == "Established"
        fail_msg: Session state "{{ bgp_summary.stdout[0].vrfs.default.peers[bgp_neighbor.key].peerState }}", expected Established
        quiet: yes
      loop: "{{ router_bgp.neighbors | default({}) | dict2items }}"
      loop_control:
        loop_var: bgp_neighbor
      when: |
        (router_bgp is defined and router_bgp is not none) and
        (router_bgp.neighbors is defined and router_bgp.neighbors is not none) and
        (bgp_neighbor.value.peer_group == "IPv4-UNDERLAY-PEERS" or bgp_neighbor.value.peer_group == "MLAG-IPv4-UNDERLAY-PEER")
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - bgp_session_state

    - name: Validate bgp evpn neighbors peer state
      assert:
        that:
          - bgp_summary.stdout[1].vrfs.default.peers[bgp_neighbor.key].peerState == "Established"
        fail_msg: Session state "{{ bgp_summary.stdout[1].vrfs.default.peers[bgp_neighbor.key].peerState }}", expected Established
        quiet: yes
      loop: "{{ router_bgp.neighbors | default({}) | dict2items }}"
      loop_control:
        loop_var: bgp_neighbor
      when: |
        (router_bgp is defined and router_bgp is not none) and
        (router_bgp.neighbors is defined and router_bgp.neighbors is not none) and
        (bgp_neighbor.value.peer_group == "EVPN-OVERLAY-PEERS")
      ignore_errors: "{{ validation_mode_loose }}"
      tags:
        - bgp_session_state